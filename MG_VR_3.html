<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>VR джойстик дебъг</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #info, #axesInfo, #btnInfo, #distInfo {
      position: absolute;
      left: 10px;
      padding: 6px 10px;
      background: rgba(0,0,0,0.8);
      color: #e5e5e5;
      font-family: monospace;
      font-size: 13px;
      z-index: 10;
      white-space: pre;
    }
    #info     { top: 10px;  color:#a3e635; }
    #axesInfo { top: 40px;  color:#38bdf8; }
    #btnInfo  { top: 90px;  color:#f97316; }
    #distInfo { top: 140px; color:#facc15; }
  </style>
</head>
<body>
  <div id="info">Sources: --</div>
  <div id="axesInfo">Axes: []</div>
  <div id="btnInfo">Buttons: []</div>
  <div id="distInfo">Разстояние: -- см</div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { VRButton } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/VRButton.js";

    const infoEl     = document.getElementById('info');
    const axesInfoEl = document.getElementById('axesInfo');
    const btnInfoEl  = document.getElementById('btnInfo');
    const distInfoEl = document.getElementById('distInfo');

    // --- Сцена, камера, рендърер ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 0.1, 20);

    const camera = new THREE.PerspectiveCamera(
      70,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(0, 1.6, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(VRButton.createButton(renderer));

    // --- Светлина и под ---
    const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 1.0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(3, 5, 2);
    scene.add(dir);

    const floorGeo = new THREE.CircleGeometry(5, 64);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x202225, roughness: 1 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    scene.add(floor);

    const grid = new THREE.GridHelper(10, 20, 0x555555, 0x333333);
    grid.position.y = 0.001;
    scene.add(grid);

    // --- Обекти: сензор, топка, LED ---
    const sensor = new THREE.Mesh(
      new THREE.BoxGeometry(0.6, 0.3, 0.3),
      new THREE.MeshStandardMaterial({ color: 0x00ffcc })
    );
    sensor.position.set(0, 1.4, -2);
    scene.add(sensor);

    const targetMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    const target = new THREE.Mesh(
      new THREE.SphereGeometry(0.25, 24, 16),
      targetMat
    );
    target.position.set(0, 1.4, -3);
    scene.add(target);

    const ledMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
    const led = new THREE.Mesh(
      new THREE.SphereGeometry(0.15, 16, 16),
      ledMat
    );
    led.position.set(0.8, 1.4, -2.5);
    scene.add(led);

    // --- WebXR session ---
    function getXRSession() {
      return renderer.xr.getSession ? renderer.xr.getSession() : null;
    }

    // --- Разстояние и LED ---
    function updateDistance() {
      const d = sensor.position.distanceTo(target.position);
      const cm = Math.round(d * 100); // условни "сантиметри"
      distInfoEl.textContent = `Разстояние: ${cm} см`;

      if (cm < 30) {
        ledMat.color.set(0xff0000);
      } else if (cm < 60) {
        ledMat.color.set(0xffff00);
      } else {
        ledMat.color.set(0x00ff00);
      }
    }

    // --- Четене на всички оси / бутони и местене на топката ---
    function updateGamepad(delta) {
      const session = getXRSession();
      if (!session) {
        infoEl.textContent = "Sources: (няма XR сесия)";
        axesInfoEl.textContent = "Axes: []";
        btnInfoEl.textContent  = "Buttons: []";
        return;
      }

      const sources = session.inputSources || [];
      infoEl.textContent = `Sources: ${sources.length}`;

      let axesText = "";
      let btnText  = "";
      let moveX = 0;
      let moveY = 0;

      for (let si = 0; si < sources.length; si++) {
        const src = sources[si];
        if (!src.gamepad) {
          axesText += `#${si}: (no gamepad)\n`;
          continue;
        }
        const gp = src.gamepad;

        // оси
        const axes = gp.axes || [];
        axesText += `#${si} axes: [${axes.map(a => a.toFixed(2)).join(", ")}]\n`;

        // бутони
        const btns = gp.buttons || [];
        const btnStates = btns.map(b => (b.pressed ? "1" : "0")).join("");
        btnText += `#${si} btn: ${btnStates}\n`;

        // избор на "най-активните" две оси за движение
        if (axes.length >= 2) {
          // намираме индексите на двете най-големи по абсолютна стойност оси
          let first = 0, second = 1;
          for (let i = 0; i < axes.length; i++) {
            if (Math.abs(axes[i]) > Math.abs(axes[first])) {
              second = first;
              first = i;
            } else if (i !== first && Math.abs(axes[i]) > Math.abs(axes[second])) {
              second = i;
            }
          }

          const axX = axes[first] || 0;
          const axY = axes[second] || 0;

          // Накрая ще използваме осите от ПЪРВИЯ gamepad, който намерим
          moveX = axX;
          moveY = axY;
          break; // стига ни един контролер
        }
      }

      axesInfoEl.textContent = axesText || "Axes: []";
      btnInfoEl.textContent  = btnText  || "Buttons: []";

      // ако няма оси – не местим
      if (moveX === 0 && moveY === 0) return;

      const deadZone = 0.15;
      if (Math.abs(moveX) < deadZone && Math.abs(moveY) < deadZone) return;

      const speed = 1.5 * delta;

      target.position.x += moveX * speed;
      target.position.y += -moveY * speed; // минус за по-интуитивно

      target.position.z = -3;

      target.position.x = THREE.MathUtils.clamp(target.position.x, -1.5, 1.5);
      target.position.y = THREE.MathUtils.clamp(target.position.y, 0.5, 2.2);
    }

    // --- Анимация ---
    let lastTime = 0;
    renderer.setAnimationLoop((time) => {
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      sensor.rotation.y += delta * 0.5;

      updateGamepad(delta);
      updateDistance();

      renderer.render(scene, camera);
    });

    // --- Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
